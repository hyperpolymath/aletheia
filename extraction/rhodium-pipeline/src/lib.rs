//! Rhodium Pipeline - CI/CD Pipeline Generator
//!
//! Generates RSR-compliant CI/CD configurations for various platforms.
//!
//! # Features
//!
//! - Zero dependencies (uses only Rust std library)
//! - Template-based pipeline generation
//! - Multi-platform support (GitHub, GitLab, CircleCI, Jenkins)
//! - RSR compliance enforcement

use std::path::Path;

/// Library version
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

/// Supported CI/CD platforms
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Platform {
    GitHub,
    GitLab,
    CircleCI,
    Jenkins,
}

impl Platform {
    /// Parse platform from string
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "github" | "gh" => Some(Platform::GitHub),
            "gitlab" | "gl" => Some(Platform::GitLab),
            "circleci" | "circle" => Some(Platform::CircleCI),
            "jenkins" => Some(Platform::Jenkins),
            _ => None,
        }
    }

    /// Get the default output path for this platform
    pub fn default_path(&self) -> &'static str {
        match self {
            Platform::GitHub => ".github/workflows/ci.yml",
            Platform::GitLab => ".gitlab-ci.yml",
            Platform::CircleCI => ".circleci/config.yml",
            Platform::Jenkins => "Jenkinsfile",
        }
    }
}

/// Pipeline compliance level
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PipelineLevel {
    Bronze,
    Silver,
    Gold,
    Platinum,
}

/// Pipeline generation options
#[derive(Debug, Clone)]
pub struct PipelineOptions {
    pub platform: Platform,
    pub level: PipelineLevel,
    pub include_deploy: bool,
    pub project_name: String,
    pub rust_version: String,
}

impl Default for PipelineOptions {
    fn default() -> Self {
        Self {
            platform: Platform::GitHub,
            level: PipelineLevel::Bronze,
            include_deploy: false,
            project_name: String::from("project"),
            rust_version: String::from("stable"),
        }
    }
}

/// Generate GitHub Actions workflow
pub fn generate_github_actions(options: &PipelineOptions) -> String {
    format!(
        r#"# RSR-Compliant CI/CD Pipeline
# Generated by Rhodium Pipeline v{version}
# Level: {level:?}

name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  schedule:
    - cron: '0 0 * * 1' # Weekly

env:
  CARGO_TERM_COLOR: always
  RUSTFLAGS: -Dwarnings

jobs:
  # Stage 1: Check
  check:
    name: Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-action@{rust_version}

      - name: Check formatting
        run: cargo fmt --check

      - name: Clippy
        run: cargo clippy -- -D warnings

      - name: Check for unsafe code
        run: |
          if grep -r "unsafe" src/; then
            echo "::error::Unsafe code detected!"
            exit 1
          fi

      - name: Check for dependencies
        run: |
          deps=$(cargo tree --depth 0 | grep -c "^")
          if [ "$deps" -gt 1 ]; then
            echo "::error::External dependencies detected!"
            cargo tree
            exit 1
          fi

  # Stage 2: Test
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: check
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-action@{rust_version}

      - name: Run tests
        run: cargo test --verbose

      - name: Run tests (release)
        run: cargo test --release --verbose

      - name: Doc tests
        run: cargo test --doc

  # Stage 3: Build
  build:
    name: Build
    runs-on: ${{{{ matrix.os }}}}
    needs: test
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-action@{rust_version}

      - name: Build release
        run: cargo build --release

      - name: Upload binary
        uses: actions/upload-artifact@v4
        with:
          name: {project_name}-${{{{ matrix.os }}}}
          path: |
            target/release/{project_name}
            target/release/{project_name}.exe

  # Stage 4: Verify RSR Compliance
  verify:
    name: RSR Compliance
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-action@{rust_version}

      - name: Build
        run: cargo build --release

      - name: Self-verify
        run: cargo run -- check . || true

      - name: Generate badge
        run: |
          echo "![RSR Bronze](https://img.shields.io/badge/RSR-Bronze-cd7f32)" > RSR_BADGE.md
"#,
        version = VERSION,
        level = options.level,
        rust_version = options.rust_version,
        project_name = options.project_name,
    )
}

/// Generate GitLab CI configuration
pub fn generate_gitlab_ci(options: &PipelineOptions) -> String {
    format!(
        r#"# RSR-Compliant CI/CD Pipeline
# Generated by Rhodium Pipeline v{version}
# Level: {level:?}

stages:
  - check
  - test
  - build
  - verify

variables:
  CARGO_HOME: ${{CI_PROJECT_DIR}}/.cargo
  RUSTFLAGS: "-Dwarnings"

.rust-template:
  image: rust:{rust_version}
  cache:
    key: ${{CI_COMMIT_REF_SLUG}}
    paths:
      - .cargo/
      - target/

# Stage 1: Check
fmt:
  extends: .rust-template
  stage: check
  script:
    - cargo fmt --check

clippy:
  extends: .rust-template
  stage: check
  script:
    - rustup component add clippy
    - cargo clippy -- -D warnings

unsafe-check:
  extends: .rust-template
  stage: check
  script:
    - |
      if grep -r "unsafe" src/; then
        echo "Unsafe code detected!"
        exit 1
      fi

deps-check:
  extends: .rust-template
  stage: check
  script:
    - |
      deps=$(cargo tree --depth 0 | grep -c "^")
      if [ "$deps" -gt 1 ]; then
        echo "External dependencies detected!"
        exit 1
      fi

# Stage 2: Test
test:
  extends: .rust-template
  stage: test
  script:
    - cargo test --verbose

test-release:
  extends: .rust-template
  stage: test
  script:
    - cargo test --release --verbose

# Stage 3: Build
build-debug:
  extends: .rust-template
  stage: build
  script:
    - cargo build
  artifacts:
    paths:
      - target/debug/{project_name}
    expire_in: 1 week

build-release:
  extends: .rust-template
  stage: build
  script:
    - cargo build --release
  artifacts:
    paths:
      - target/release/{project_name}
    expire_in: 1 month

# Stage 4: Verify
verify:
  extends: .rust-template
  stage: verify
  dependencies:
    - build-release
  script:
    - ./target/release/{project_name} check . || true
"#,
        version = VERSION,
        level = options.level,
        rust_version = options.rust_version,
        project_name = options.project_name,
    )
}

/// Generate CircleCI configuration
pub fn generate_circleci(options: &PipelineOptions) -> String {
    format!(
        r#"# RSR-Compliant CI/CD Pipeline
# Generated by Rhodium Pipeline v{version}
# Level: {level:?}

version: 2.1

executors:
  rust:
    docker:
      - image: rust:{rust_version}

jobs:
  check:
    executor: rust
    steps:
      - checkout
      - run:
          name: Check formatting
          command: cargo fmt --check
      - run:
          name: Clippy
          command: cargo clippy -- -D warnings
      - run:
          name: Check for unsafe code
          command: |
            if grep -r "unsafe" src/; then
              echo "Unsafe code detected!"
              exit 1
            fi

  test:
    executor: rust
    steps:
      - checkout
      - run:
          name: Run tests
          command: cargo test --verbose
      - run:
          name: Run release tests
          command: cargo test --release --verbose

  build:
    executor: rust
    steps:
      - checkout
      - run:
          name: Build release
          command: cargo build --release
      - store_artifacts:
          path: target/release/{project_name}

  verify:
    executor: rust
    steps:
      - checkout
      - run:
          name: Build and verify
          command: |
            cargo build --release
            ./target/release/{project_name} check . || true

workflows:
  rsr-pipeline:
    jobs:
      - check
      - test:
          requires:
            - check
      - build:
          requires:
            - test
      - verify:
          requires:
            - build
"#,
        version = VERSION,
        level = options.level,
        rust_version = options.rust_version,
        project_name = options.project_name,
    )
}

/// Generate Jenkinsfile
pub fn generate_jenkinsfile(options: &PipelineOptions) -> String {
    format!(
        r#"// RSR-Compliant CI/CD Pipeline
// Generated by Rhodium Pipeline v{version}
// Level: {level:?}

pipeline {{
    agent any

    environment {{
        CARGO_HOME = "${{WORKSPACE}}/.cargo"
        RUSTFLAGS = '-Dwarnings'
    }}

    stages {{
        stage('Check') {{
            steps {{
                sh 'cargo fmt --check'
                sh 'cargo clippy -- -D warnings'
                sh '''
                    if grep -r "unsafe" src/; then
                        echo "Unsafe code detected!"
                        exit 1
                    fi
                '''
            }}
        }}

        stage('Test') {{
            steps {{
                sh 'cargo test --verbose'
                sh 'cargo test --release --verbose'
            }}
        }}

        stage('Build') {{
            steps {{
                sh 'cargo build --release'
            }}
            post {{
                success {{
                    archiveArtifacts artifacts: 'target/release/{project_name}', fingerprint: true
                }}
            }}
        }}

        stage('Verify') {{
            steps {{
                sh './target/release/{project_name} check . || true'
            }}
        }}
    }}

    post {{
        always {{
            cleanWs()
        }}
    }}
}}
"#,
        version = VERSION,
        level = options.level,
        project_name = options.project_name,
    )
}

/// Generate pipeline configuration for the specified platform
pub fn generate_pipeline(options: &PipelineOptions) -> String {
    match options.platform {
        Platform::GitHub => generate_github_actions(options),
        Platform::GitLab => generate_gitlab_ci(options),
        Platform::CircleCI => generate_circleci(options),
        Platform::Jenkins => generate_jenkinsfile(options),
    }
}

/// Validation result
#[derive(Debug)]
pub struct ValidationResult {
    pub valid: bool,
    pub errors: Vec<String>,
    pub warnings: Vec<String>,
}

/// Validate an existing pipeline configuration
pub fn validate_pipeline(path: &Path) -> ValidationResult {
    let mut result = ValidationResult {
        valid: true,
        errors: Vec::new(),
        warnings: Vec::new(),
    };

    // Check for GitHub Actions
    let github_path = path.join(".github/workflows");
    let gitlab_path = path.join(".gitlab-ci.yml");
    let circleci_path = path.join(".circleci/config.yml");
    let jenkins_path = path.join("Jenkinsfile");

    let has_ci = github_path.exists()
        || gitlab_path.exists()
        || circleci_path.exists()
        || jenkins_path.exists();

    if !has_ci {
        result.errors.push("No CI/CD configuration found".to_string());
        result.valid = false;
    }

    // Check for required elements (basic validation)
    if github_path.exists() {
        if let Ok(entries) = std::fs::read_dir(&github_path) {
            let has_workflow = entries
                .filter_map(|e| e.ok())
                .any(|e| e.path().extension().map(|ext| ext == "yml").unwrap_or(false));
            if !has_workflow {
                result
                    .warnings
                    .push("No workflow files in .github/workflows/".to_string());
            }
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_platform_parsing() {
        assert_eq!(Platform::from_str("github"), Some(Platform::GitHub));
        assert_eq!(Platform::from_str("gitlab"), Some(Platform::GitLab));
        assert_eq!(Platform::from_str("invalid"), None);
    }

    #[test]
    fn test_default_paths() {
        assert_eq!(
            Platform::GitHub.default_path(),
            ".github/workflows/ci.yml"
        );
        assert_eq!(Platform::GitLab.default_path(), ".gitlab-ci.yml");
    }

    #[test]
    fn test_github_generation() {
        let options = PipelineOptions::default();
        let result = generate_github_actions(&options);
        assert!(result.contains("cargo fmt --check"));
        assert!(result.contains("cargo clippy"));
        assert!(result.contains("unsafe"));
    }

    #[test]
    fn test_gitlab_generation() {
        let options = PipelineOptions {
            platform: Platform::GitLab,
            ..Default::default()
        };
        let result = generate_gitlab_ci(&options);
        assert!(result.contains("stages:"));
        assert!(result.contains("cargo test"));
    }
}
